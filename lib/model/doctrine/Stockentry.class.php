<?php

/**
 * Stockentry
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 * 
 * @package    sf_sandbox
 * @subpackage model
 * @author     Your name here
 * @version    SVN: $Id: Builder.php 7490 2010-03-29 19:53:27Z jwage $
 */
class Stockentry extends BaseStockentry
{
	//database getters
  function getRef()
  {
    if($this->getRefClass()!="")
     return Doctrine_Query::create()
      ->from($this->getRefClass().' p')
      ->where('id ='.$this->getRefId())
      ->fetchOne();
  }
  function getStock()
  {
   return Doctrine_Query::create()
      ->from('Stock s')
      ->where('id ='.$this->getStockId())
      ->fetchOne();
  }
	//--status functions--------------------------
	//relationship: product calc adjusts max and min product prices according to quotes
	//if cancelled, ignore
  public function isCancelled(){return $this->getIsCancelled();}
  public function cancel(){$this->setIsCancelled(1);$this->save();$this->getStock()->calc();}

  //---iterator functions----------------------------------------

  public function getPreviousWithBalanceNotNull()
  {
    //this gives you all records under the same stock from current date backwards, current date first, omitting records with no balance
     $entries= Doctrine_Query::create()
        ->from('Stockentry se')
        ->orderBy('date desc, priority desc')
        ->where('stock_id ='.$this->getStockId())
        ->andWhere('date <= "'.$this->getDate().'"')
      	->andWhere('se.is_cancelled = 0')
        ->execute();

      if(count($entries)==0)return null;

      //find the current record. Return the first record with a non-null balance after that. 
      $thisfound=false;
      foreach($entries as $index=>$entry)
      {
        if($entry->getId()==$this->getId()){$thisfound=true;continue;}
        if($thisfound==true and $entry->getBalance()!=null)return $entry;
      }
      //none found. return nothing.
      return;
  }
  public function getPrevious()
  {
        return Doctrine_Query::create()
        ->from('Stockentry e')
        ->where('e.stock_id = '.$this->getStockId())
      	->andWhere('e.is_cancelled = 0')

        //before today
        ->andWhere('e.date < "'.$this->getDate().'"')

        ->orWhere('e.stock_id = '.$this->getStockId())
      	->andWhere('e.is_cancelled = 0')

        //today but with lesser priority 
        ->andWhere('e.date = "'.$this->getDate().'"')
        ->andWhere('e.priority < "'.$this->getPriority().'"')
        
        ->orderBy('date desc, priority desc')
        ->fetchOne();
  }
  public function getNext()
  {
      return Doctrine_Query::create()
        ->from('Stockentry e')
        ->where('e.stock_id = '.$this->getStockId())
      	->andWhere('e.is_cancelled = 0')
        //after today
        ->andWhere('e.date > "'.$this->getDate().'"')

        ->orWhere('e.stock_id = '.$this->getStockId())
      	->andWhere('e.is_cancelled = 0')

        //today, but only those with priority greater than current
        ->andWhere('e.date = "'.$this->getDate().'"')
        ->andWhere('e.priority > "'.$this->getPriority().'"')
        
        ->orderBy('date, priority')
        ->fetchOne();
  }
  public function getLast()
  {
      return Doctrine_Query::create()
        ->from('Stockentry e')
        ->where('e.stock_id = '.$this->getStockId())
      	->andWhere('e.is_cancelled = 0')
        ->orderBy('date desc, priority desc')
        ->fetchOne();
  }
  public function getFirst()
  {
      return Doctrine_Query::create()
        ->from('Stockentry e')
        ->where('e.stock_id = '.$this->getStockId())
      	->andWhere('e.is_cancelled = 0')
        ->orderBy('date, priority')
        ->fetchOne();
  }
  //Getnext()
  //Getlasttoday()
  public function getLastForDate($date)
  {
     return Doctrine_Query::create()
        ->from('Stockentry se')
        ->orderBy('priority desc')
        ->where('stock_id ='.$this->getStockId())
        ->andWhere('date <= "'.$date.'"')
        ->fetchOne();
  }

  //Insert(): 
  /*
  //this is complicated. Let stock participate.
  stock->insert(array(
                      'date'            <required
                      'qty'             <required
                      'balance'                       <calculated
                      'stock_id'                      <derived
                      'ref_class'       <optional
                      'ref_id'          <optional
                      'is_fwd'                                              <unused
                      'is_cancelled'                                        <unused
                      'priority'                      <calculated
                      'previous_id'                   <calculated
                      'type'                                                <unused
                      ))
  public function insert()
  {
    
  }
  */

  //Delete()
  /*
  public function deleteEntry()
  {
    $previous=$this->getPrevious();

    //if no previous, meaning we're deleting the very first record
    if(!$previous)
    {
      //get the next one instead
      $previous=$this->getNext();

      //no next record either - just delete it and reset stock qty to 0
      if(!$previous)
      {
        $stock=$this->getStock();
        $stock->setCurrentqty(0);
        $stock->save();
        
        return $this->delete();
      }

      //adjust qty of next entry, that is, first among remaining entries
      $previous->setBalance($previous->getQty());
      $previous->save();
    }
    
    $result=$this->delete();

    //adjust balances of all entries
    $previous->getStock()->calcFromStockEntry($previous);

    return $result;
  }*/
  public function delete(Doctrine_Connection $conn=null)
  {
    $previous=$this->getPrevious();

    //if no previous, meaning we're deleting the very first record
    if(!$previous)
    {
      //get the next one instead
      $previous=$this->getNext();

      //no next record either - just delete it and reset stock qty to 0
      if(!$previous)
      {
        $stock=$this->getStock();
        $stock->setCurrentqty(0);
        $stock->save($conn);
        
        return parent::delete($conn);
      }

      //adjust qty of next entry, that is, first among remaining entries
      $previous->setBalance($previous->getQty());
      $previous->save($conn);
    }
    
    $result=parent::delete($conn);

    //adjust balances of all entries
    $previous->getStock()->calcFromStockEntry($previous);

    return $result;
  }
  //only for use of stock->delete
  public function cascadeDelete(Doctrine_Connection $conn=null)
  {
    return parent::delete($conn);
  }
}
